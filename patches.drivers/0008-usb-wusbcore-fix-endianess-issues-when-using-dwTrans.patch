From f4ea11bc147d60f70e6e7a04aee42e0394b535cf Mon Sep 17 00:00:00 2001
From: Thomas Pugliese <thomas.pugliese@gmail.com>
Date: Fri, 27 Sep 2013 15:33:35 -0500
Patch-Mainline: v3.13
References: bnc#852581
Git-Commit: fdd160c3088f7e7de033cd31f4d11f38fc24803d
Subject: [PATCH 08/24] usb: wusbcore: fix endianess issues when using
 dwTransferID

Add a new function to get the xfer ID in little endian format
(wa_xfer_id_le32), and use it instead of wa_xfer_id where appropriate.

Signed-off-by: Thomas Pugliese <thomas.pugliese@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Oliver Neukum <oneukum@suse.de>
---
 drivers/usb/wusbcore/wa-xfer.c | 20 +++++++++++---------
 1 file changed, 11 insertions(+), 9 deletions(-)

diff --git a/drivers/usb/wusbcore/wa-xfer.c b/drivers/usb/wusbcore/wa-xfer.c
index 0b27146..6f935d5 100644
--- a/drivers/usb/wusbcore/wa-xfer.c
+++ b/drivers/usb/wusbcore/wa-xfer.c
@@ -308,16 +308,18 @@ static void wa_xfer_id_init(struct wa_xfer *xfer)
 	xfer->id = atomic_add_return(1, &xfer->wa->xfer_id_count);
 }
 
-/*
- * Return the xfer's ID associated with xfer
- *
- * Need to generate a
- */
-static u32 wa_xfer_id(struct wa_xfer *xfer)
+/* Return the xfer's ID. */
+static inline u32 wa_xfer_id(struct wa_xfer *xfer)
 {
 	return xfer->id;
 }
 
+/* Return the xfer's ID in transport format (little endian). */
+static inline __le32 wa_xfer_id_le32(struct wa_xfer *xfer)
+{
+	return cpu_to_le32(xfer->id);
+}
+
 /*
  * Search for a transfer list ID on the HCD's URB list
  *
@@ -381,7 +383,7 @@ static void __wa_xfer_abort(struct wa_xfer *xfer)
 	b->cmd.bLength =  sizeof(b->cmd);
 	b->cmd.bRequestType = WA_XFER_ABORT;
 	b->cmd.wRPipe = rpipe->descr.wRPipeIndex;
-	b->cmd.dwTransferID = wa_xfer_id(xfer);
+	b->cmd.dwTransferID = wa_xfer_id_le32(xfer);
 
 	usb_init_urb(&b->urb);
 	usb_fill_bulk_urb(&b->urb, xfer->wa->usb_dev,
@@ -477,7 +479,7 @@ static void __wa_xfer_setup_hdr0(struct wa_xfer *xfer,
 	xfer_hdr0->bLength = xfer_hdr_size;
 	xfer_hdr0->bRequestType = xfer_type;
 	xfer_hdr0->wRPipe = rpipe->descr.wRPipeIndex;
-	xfer_hdr0->dwTransferID = wa_xfer_id(xfer);
+	xfer_hdr0->dwTransferID = wa_xfer_id_le32(xfer);
 	xfer_hdr0->bTransferSegment = 0;
 	switch (xfer_type) {
 	case WA_XFER_TYPE_CTL: {
@@ -1750,7 +1752,7 @@ static void wa_dti_cb(struct urb *urb)
 		if (usb_status == WA_XFER_STATUS_NOT_FOUND)
 			/* taken care of already */
 			break;
-		xfer_id = xfer_result->dwTransferID;
+		xfer_id = le32_to_cpu(xfer_result->dwTransferID);
 		xfer = wa_xfer_get_by_id(wa, xfer_id);
 		if (xfer == NULL) {
 			/* FIXME: transaction might have been cancelled */
-- 
1.8.4

